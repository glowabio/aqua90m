<!--#https://www.geeksforgeeks.org/using-leaflet-js-to-show-maps-in-a-webpage/-->

<!-- TODO: -->
<!-- Reclick on a marker, need to change behaviour...  -->
<!-- Add download data as xyz button -->
<!-- Always show stream segment and its strahler? -->
<!-- Polygons: Show strahler order as colour! -->
<!-- Add login, more subcatchments?? -->

<!DOCTYPE html>
<html>

<head>
  <title>Hydrography90m</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Get the leaflet CSS file -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
integrity=
"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
    crossorigin="" />
  <link rel="stylesheet" href="mystyle.css"/ >
</head>

<body>
<div id="container">
  <div id="header">
    <a href="https://aquainfra.eu"><img src="logo_aquainfra.svg" height="35px" /></a>
  </div>

  <div id="body">
  <h1>On the fly upstream catchments</h1>
  <!--h1>TEMPORARILY OFFLINE: On the fly upstream catchments</h1-->


  <!-- Selection -->
  <p><span>Click on the map to display:</span></p>
  <select id="processes">
    <optgroup label="upstream">
      <option data-pairs="one" value="get-upstream-bbox">Upstream bounding box</option>
      <option data-pairs="one" value="get-upstream-dissolved-cont">Upstream catchment (one large polygon)</option>
      <option data-pairs="one" value="get-upstream-subcatchments">Upstream catchment (individual polygons)</option>
      <option data-pairs="one" value="get-upstream-streamsegments" selected="selected">Upstream stream segments</option>
    </optgroup>
    <optgroup label="local">
      <option data-pairs="one" value="get-local-streamsegments">Local stream segment</option>
      <option data-pairs="one" value="get-local-streamsegments-subcatchments">Local stream segment and local subcatchment</option>
      <option data-pairs="one" value="get-snapped-points">Snapped point</option>
      <option data-pairs="one" value="get-snapped-point-plus">Snapped point, local stream segment and local subcatchment</option>
    </optgroup>
    <optgroup label="routing">
      <option data-pairs="one" value="get-shortest-path-to-outlet">Shortest path from point to sea</option>
      <option data-pairs="two" value="get-shortest-path-between-points">Shortest path from point to point</option>
    </optgroup>
  </select>
  <label><input type="checkbox" id="stylingStrahlerToggle" checked>Style depending on <strong>strahler</strong> order</label>
  <div>(please choose!)...</div>
  <p id="scrollToTop">
    <span class="greynote">Note: Computing may take some time, depending on catchment size!</span>
    <br />
    <span class="greynote">Note: In case you click to a headwater, no upstream catchment is provided, as no upstream exists...</span>
  </p>


  <!-- Map -->
  <div id="map"></div>
  <!-- Behaviour is defined programmatically further below -->
  <p><button id="clearMapButton">Clear the map!</button></p>

  <!-- Custom lonlat button -->
  <h3>Input your own coordinates...</h3>
  <table>
    <tr>
    <!-- If you want the grey examples to disappear on focus, set onfocus to this:   onfocus="if(this.value=='9.17'){ this.value='NIX'; this.style.color='#000';}"   -->
      <td>Longitude:</td>
      <td>
        <input type="text" id="customLon1" value="9.0409"
          onblur="if(this.value==''){ this.value='9.0409'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='9.0409'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. <span class="code">9.0409</span></td>
      <td class="fortwo invisible">
        <input type="text" id="customLon2" value="8.99853"
          onblur="if(this.value==''){ this.value='8.99853'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='8.99853'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td class="fortwo invisible">e.g. <span class="code">9.17</span></td>
    </tr>
    <tr>
      <td>Latitude:</td>
      <td>
        <input type="text" id="customLat1" value="52.7769"
          onblur="if(this.value==''){ this.value='52.7769'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='52.7769'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. <span class="code">52.95</span></td>
      <td class="fortwo invisible">
        <input type="text" id="customLat2" value="52.799"
          onblur="if(this.value==''){ this.value='52.799'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='52.799'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td class="fortwo invisible">e.g. <span class="code">52.95</span></td>
    </tr>
    <tr>
      <td>Lon lat:</td>
      <td>
        <input type="text" id="customLonLat1" value="9.0409, 52.7769"
          onblur="if(this.value==''){ this.value='9.0409, 52.7769'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='9.0409, 52.7769'; this.style.color='#000';} else {this.style.color='#000';}"
          onfocus="{ this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. <span class="code">8.99853, 52.799</span></td>
      <td class="fortwo invisible">
        <input type="text" id="customLonLat2" value="8.99853, 52.799"
          onblur="if(this.value==''){ this.value='8.99853, 52.799'; this.style.color='#BBB';}"
          onfocus="if(this.value==''){ this.value='8.99853, 52.799'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td class="fortwo invisible">e.g. <span class="code">9.17, 52.95</span></td>
    </tr>
    <tr>
      <td>Subcatchment id:</td>
      <td>
        <input type="text" id="customSubc1" value=""
          onfocus="if(this.value==''){ this.value='507044912'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. <span class="code">507044912</span></td>
      <td class="fortwo invisible">
        <input type="text" id="customSubc2" value=""
          onfocus="if(this.value==''){ this.value='506924326'; this.style.color='#000';} else {this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td class="fortwo invisible">e.g. <span class="code">506924326</span></td>
    </tr>
  </table>
  <!-- Behaviour is defined programmatically further below -->
  <p><button id="customLonlatButton">Use these values!</button> (The result will be displayed in the map above)</p>


  <!-- Example buttons -->
  <h3>...or use these examples:</h3>
  <p>(The result will be displayed in the map above):</p>
  <table>
    <tr>
      <td><button id="example1" thislon="not set" thislat="not set">not set</button></td>
      <td id="example1desc">(not set)</td>
    </tr>
    <tr>
      <td><button  id="example2" thislon="not set" thislat="not set">not set</button></td>
      <td id="example2desc">(not set)</td>
    </tr>
    <tr>
      <td><button  id="example3" thislon="not set" thislat="not set">not set</button></td>
      <td id="example3desc">(not set)</td>
    </tr>
    <tr>
      <td><button  id="example4" thislon="not set" thislat="not set">not set</button></td>
      <td id="example4desc">(not set)</td>
    </tr>
    <tr>
      <td><button  id="example5" thislon="not set" thislat="not set">not set</button></td>
      <td id="example5desc">(not set)</td>
    </tr>
  </table>


  <!-- Text field for response -->
  <h3>Response returned by server:</h3>
  <p id="responseField">Response returned by server:</p>
  <p><textarea id="displayGeoJSON" class="codeblock" rows="20", cols="120">(Result GeoJSON will be displayed here)</textarea></p>

  <!-- Text field for adding custom GeoJSON -->
  <h3>Enter GeoJSON:</h3>
  <textarea id="customGeoJsonArea" class="codeblock" rows="5" cols="120" placeholder='Paste valid GeoJSON here'></textarea>
  <button id="customGeoJsonButton">Display on map</button>

  <h3>Data sources</h3>
  <p>The data based on which the above functionalities are computed is the <strong>Hydrography90m dataset</strong> (see <a href="https://hydrography.org">hydrography.org</a>), especially the vector layers contained in the <strong>GeoFRESH database</strong> (see <a href="https://geofresh.org">geofresh.org</a>):
  </p>
  <p class="cite">
    Amatulli, G., Garcia Marquez, J.R., Sethi, T., Kiesel, J., Grigoropoulou, A., Üblacker, M., Shen, L., Domisch, S. (2022). Hydrography90m: A new high-resolution global hydrographic dataset. Earth System Science Data, 14, 4525–4550.<br/><a href="https://doi.org/10.5194/essd-14-4525-2022">doi:10.5194/essd-14-4525-2022</a>.
  </p>
  <p class="cite">
    Domisch, S., Bremerich, V., Buurman, M., Kaminke, B., Tomiczek, T., Torres-Cambas, Y., Grigoropoulou, A., Garcia Marquez, J. R., Amatulli, G., Grossart, H. P., Gessner, M. O., Mehner, T., Adrian, R. & De Meester, L. (2024). GeoFRESH – an online platform for freshwater geospatial data processing. International Journal of Digital Earth, 17(1).<br/><a href="https://doi.org/10.1080/17538947.2024.2391033">doi:10.1080/17538947.2024.2391033</a>.
  </p>

  </div> <!-- end of body -->
  <div id="footer">
    <a href="https://www.igb-berlin.de/"><img src="logo_igb.svg" height="35px" /></a>
    <span id="contact"><a id="contact" href="https://glowabio.org/about/">Contact (GLOWABIO working group)</a></span>
  </div>
</div> <!-- end of container -->




  <!-- Get the leaflet JavaScript file -->
  <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
    integrity=
"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
    crossorigin=""></script>
  <script>

    // Initialize the map
    const map = L.map('map')

    // Collect layers so I can remove them:
    var allMyLayers = [];
    var allMyIcons = [];

    // Get the tile layer from OpenStreetMaps
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, // maximum zoom of map
      attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Set the view of the map
    // with the latitude, longitude and the zoom value
    // map.setView([60.19123, 24.94612], 10); // Helsinki
    map.setView([53.014, 12.008], 7); // Northern Germany

    // Other way. WORKS!
    //L.geoJSON(data, {
    //    style: function(feature) {
    //        switch (feature.properties.UnitID) {
    //            case 1: return {color: "#ff0000"};
    //            case 2: return {color: "#0000ff"};
    //      default: return {color: "#ff8c00"};
    //        }
    //    }
    //}).addTo(map);


    ///////////////////////////////////////////////
    ////// Functions for colouring / styling //////
    ///////////////////////////////////////////////

    // Colour conversion function for strahler-colouring.
    // TODO: Move to separate javascript and import
    var convert_hsl_to_hex = function(h, s, l) {

      let hsl2rgb = function(h,s,l) {
        // Source:
        // https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
        let a=s*Math.min(l,1-l);
        let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);
        //return [f(0),f(8),f(4)]; // values between 0 and 1
        return [f(0)*255,f(8)*255,f(4)*255];
      }

      let componentToHex = function(c) {
        // Source:
        // https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#5624139
        //console.log(' (rgb val '+c+')')
        let rounded = Math.round(c)
        //console.log(' (rounded '+rounded+')')
        var hex = rounded.toString(16);
        //console.log(' (hexed '+hex+')')
        return hex.length == 1 ? "0" + hex : hex;
      }

      let rgbToHex = function(r, g, b) {
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
      }

      let col_rgb = hsl2rgb(h, s, l);
      let col_hex = rgbToHex(col_rgb[0], col_rgb[1], col_rgb[2]);
      return (col_hex);
    }

    // Lightness conversion function for strahler-colouring.
    // TODO: Move to separate javascript and import
    // TODO: EFFICIENCY: Would be good to precompute, as we have few strahler-orders, and many features...
    var strahler_to_hsl_lightness = function(strahler, lowest_lightness, highest_lightness) {
      strahler = parseInt(strahler);
      let tmp = 11-strahler;

      // Make zero if negative, for strahler > 11, i.e. rivers bigger than Danube!
      if (tmp < 0) {
        tmp = 0;
      }

      //let lightness = 0.2 + ((0.9-0.2)*0.1) * tmp
      let lightness = lowest_lightness + (highest_lightness - lowest_lightness) * tmp * 0.1
      return lightness
    }

    // Line weight conversion function for strahler-colouring.
    // TODO: Move to separate javascript and import
    // TODO: EFFICIENCY: Would be good to precompute, as we have few strahler-orders, and many features...
    var strahler_to_line_weight = function(strahler, min_weight=2, max_weight=4) {
      let slope = (max_weight - min_weight)/10 // 10 is approximately strahler spread...
      let add = min_weight - slope * 1 // 1 is minimum strahler
      let weight = add + slope*strahler
      //console.log('Strahler: '+strahler+', line weight: '+weight);
      return(weight)
    }

    var styleLayerUni = function(layer) {
      // Depending on process:
      // Upstream bbox = Grey
      // Upstream (segments, catchments) = Navy
      // Local (segment, catchment) = Blue #3366cc
      // Downstream = Light blue
      // Connecting line = red dashed
      // TODO: In upstream catchment, distinguish local and upstream (in feature properties, then here style!)
      // TODO: Display number of subcatchment? Does server return them?

      // Which process?
      var dropdown = document.getElementById("processes");
      var processId = dropdown.value;

      if (processId == "get-upstream-bbox") {
        layer.setStyle({fillColor: 'grey', color: 'grey'});

      } else if (processId == "get-shortest-path-to-outlet") {
        layer.setStyle({color: '#00b8e6', weight: 8});
        // This layer can already be styled based on strahler!

      } else if (processId == "get-upstream-dissolved-cont") {
        layer.setStyle({color: 'navy', weight: 5});

      } else if (processId == "get-upstream-subcatchments") {
        layer.setStyle({color: 'navy', weight: 1});

      } else if (processId == "get-upstream-streamsegments") {
        layer.setStyle({color: 'navy', weight: 4});
        // This layer can already be styled based on strahler!

      } else if (processId == "get-local-streamsegments") {
        layer.setStyle({color: '#3366cc', weight: 4});

      } else if (processId == "get-local-streamsegments-subcatchments") {
        if (layer.feature.geometry.type == 'LineString') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 4});
        } else if (layer.feature.geometry.type == 'MultiPolygon') {
          layer.setStyle({color: '#3366cc', fillColor: '#3366cc', weight: 0});
        } else {
          console.log('TODO: Found feature that is neither LineString nor MultiPolygon. You may want to check this.');
          console.log('PAINTED IT PINK!')
          layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
        };

      } else if (processId == "get-shortest-path-between-points") {
        layer.setStyle({color: '#00b8e6', weight: 8});
        // This layer can already be styled based on strahler!

      } else if (processId == "get-snapped-point-plus") {
        if (layer.feature.properties.description == 'connecting line') {
          layer.setStyle({fillColor: 'red', color: 'red', weight: 1, dashArray: '8 4'});
          console.log('Found a connecting line and painted it dashed red...');
        } else if (layer.feature.geometry.type == 'LineString') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 4});
        } else if (layer.feature.geometry.type == 'MultiPolygon') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 0});
        } else if (layer.feature.geometry.type == 'Point') {
          // TODO How to style points?
        } else {
          console.log('TODO: Found feature that is neither LineString nor MultiPolygon nor Point. You may want to check this.');
          console.log('PAINTED IT PINK!')
          layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
        };

      } else if (processId == "get-snapped-points") {
          // TODO How to style points?
          //layer.setStyle({color: 'black', weight: 3});
          //console.log('Found snapped point and painted them black...');

      // All others:
      } else {
        console.log('TODO: Found feature that is not styled yet. You may want to check this.');
        console.log('PAINTED IT PINK!')
        layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
      }
    };

    var styleLayerStrahler = function(layer) {
      // Depending on process:
      // Upstream bbox = Grey
      // Upstream (segments, catchments) = Navy
      // Local (segment, catchment) = Blue #3366cc
      // Downstream = Light blue
      // Connecting line = red dashed
      // TODO: In upstream catchment, distinguish local and upstream (in feature properties, then here style!)
      // TODO: Display number of subcatchment? Does server return them?

      // Which process?
      var dropdown = document.getElementById("processes");
      var processId = dropdown.value;

      if (processId == "get-upstream-bbox") {
        layer.setStyle({fillColor: 'grey', color: 'grey'});
        // Cannot differentiate by strahler: Just a bbox!

      } else if (processId == "get-shortest-path-to-outlet") {
        // let's vary colour with strahler order, more precisely with
        // lightness in the HSL colour model:
        // Blue: hue=192, saturation=1
        //  lightness = 0.5 or 50% medium blue
        //  lightness = 0.2 or 20% black-ish
        //  lightness = 0.9 or 90% quite light
        // Reasonable base colour to start with. Now vary lightness with strahler...
        let hue = 192;
        let saturation = 1;
        let lightness = 0.5

        // Get from strahler to a lightness value between 0.2 and 0.9!
        let strahler = layer.feature.properties.strahler_order;
        let lowest_lightness = 0.2
        let highest_lightness = 0.9
        lightness = strahler_to_hsl_lightness(strahler, lowest_lightness, highest_lightness);
        let col_hex = convert_hsl_to_hex(hue, 1, lightness);
        layer.setStyle({color: col_hex, weight: 8});

      } else if (processId == "get-upstream-dissolved-cont") {
        layer.setStyle({color: 'navy', weight: 5});
        // Cannot differentiate by strahler: Polygons are dissolved!

      } else if (processId == "get-upstream-subcatchments") {
        layer.setStyle({color: 'navy', weight: 1});
        // TODO! Strahler-Style for upstream catchments

      } else if (processId == "get-upstream-streamsegments") {
        // let's vary colour with strahler order, more precisely with
        // lightness in the HSL colour model:
        // Navy: hue=240, saturation=1
        //  lightness = 0.25 or 25% medium blue
        //  lightness = 0.2 or 20% black-ish
        //  lightness = 0.9 or 90% quite light
        // Reasonable base colour to start with. Now vary lightness with strahler...
        let hue = 240;
        let saturation = 1;
        let lightness = 0.25

        // Get from strahler to a lightness value between 0.2 and 0.9!
        let strahler = layer.feature.properties.strahler_order;
        let lowest_lightness = 0
        let highest_lightness = 0.8
        lightness = strahler_to_hsl_lightness(strahler, lowest_lightness, highest_lightness);
        let col_hex = convert_hsl_to_hex(hue, 1, lightness);

        // Get from strahler to a line weight value between 2 and 4!
        let min_weight = 2;
        let max_weight = 4;
        let weight = strahler_to_line_weight(strahler, min_weight, max_weight)
        layer.setStyle({color: col_hex, weight: weight});

      } else if (processId == "get-local-streamsegments") {
        // TODO MAYBE! Strahler-Style, although it is not great for local stuff...
        layer.setStyle({color: '#3366cc', weight: 4});

      } else if (processId == "get-local-streamsegments-subcatchments") {
        /// TODO MAYBE! Strahler-Style, although it is not great for local stuff...
        if (layer.feature.geometry.type == 'LineString') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 4});
        } else if (layer.feature.geometry.type == 'MultiPolygon') {
          layer.setStyle({color: '#3366cc', fillColor: '#3366cc', weight: 0});
        } else {
          console.log('TODO: Found feature that is neither LineString nor MultiPolygon. You may want to check this.');
          console.log('PAINTED IT PINK!')
          layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
        };

      } else if (processId == "get-shortest-path-between-points") {
        // let's vary colour with strahler order, more precisely with
        // lightness in the HSL colour model:
        // Blue: hue=192, saturation=1
        //  lightness = 0.5 or 50% medium blue
        //  lightness = 0.2 or 20% black-ish
        //  lightness = 0.9 or 90% quite light
        // Reasonable base colour to start with. Now vary lightness with strahler...
        let hue = 192;
        let saturation = 1;
        let lightness = 0.5

        // Get from strahler to a lightness value between 0.2 and 0.9!
        let strahler = layer.feature.properties.strahler_order;
        let lowest_lightness = 0.2
        let highest_lightness = 0.9
        lightness = strahler_to_hsl_lightness(strahler, lowest_lightness, highest_lightness);
        //console.log('Looking for colour of lightness '+lightness);
        let col_hex = convert_hsl_to_hex(hue, 1, lightness);
        //console.log('Colour in HEX: '+col_hex);
        layer.setStyle({color: col_hex, weight: 8});

      } else if (processId == "get-snapped-point-plus") {
        // TODO MAYBE! Strahler-Style, although it is not great for local stuff...
        if (layer.feature.properties.description == 'connecting line') {
          layer.setStyle({fillColor: 'red', color: 'red', weight: 1, dashArray: '8 4'});
          console.log('Found a connecting line and painted it dashed red...');
        } else if (layer.feature.geometry.type == 'LineString') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 4});
        } else if (layer.feature.geometry.type == 'MultiPolygon') {
          layer.setStyle({fillColor: '#3366cc', color: '#3366cc', weight: 0});
        } else if (layer.feature.geometry.type == 'Point') {
          // TODO How to style points?
        } else {
          console.log('TODO: Found feature that is neither LineString nor MultiPolygon nor Point. You may want to check this.');
          console.log('PAINTED IT PINK!')
          layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
        };

      } else if (processId == "get-snapped-points") {
          // TODO How to style points?
          //layer.setStyle({color: 'black', weight: 3});
          //console.log('Found snapped point and painted them black...');

      // All others:
      } else {
        console.log('TODO: Found feature that is not styled yet. You may want to check this.');
        console.log('PAINTED IT PINK!')
        layer.setStyle({fillColor: 'pink', color: 'pink', weight: 3});
      }
    };


    ///////////////////////////////////////////////
    ////// Functions for making OGC requests //////
    ///////////////////////////////////////////////

    // Define making request to OGC service (function):
    var ogcRequestTwoCoordinatePairs = function(clickMarker, lon1, lat1, lon2, lat2) {

        // Reset result field:
        document.getElementById("responseField").innerHTML = "Response returned by server for <span class=\"code\">"+lon1+", "+lat1+"</span> to <span class=\"code\">"+lon2+", "+lat2+"</span> (lon, lat, WGS84)...";
        document.getElementById("displayGeoJSON").innerHTML = "waiting..."

        // Parse coordinates to Float
        var lat1 = parseFloat(lat1);
        var lon1 = parseFloat(lon1);
        var lat2 = parseFloat(lat2);
        var lon2 = parseFloat(lon2);

        // Param string for logging
        var paramstring = "lat="+lat1.toFixed(3)+", lon="+lon1.toFixed(3)+ "lat="+lat2.toFixed(3)+", lon="+lon2.toFixed(3);

        // Define JSON payload and send:
        var payload_inputs_json = JSON.stringify({"inputs": {
          "lon_start":lon1, "lat_start":lat1,
          "lon_end": lon2, "lat_end": lat2
        }})
        _ogcRequest(clickMarker, payload_inputs_json, paramstring) ;
    }

    // Define making request to OGC service (function):
    var ogcRequestOneCoordinatePair = function(clickMarker, lon1, lat1) {

        // Reset result field:
        document.getElementById("responseField").innerHTML = "Response returned by server for lon, lat <span class=\"code\">"+lon1+", "+lat1+"</span> (lon, lat, WGS84)...";
        document.getElementById("displayGeoJSON").innerHTML = "waiting..."

        // Parse coordinates to Float
        var lon1 = parseFloat(lon1);
        var lat1 = parseFloat(lat1);

        // Param string for logging
        var paramstring = "lat="+lat1.toFixed(3)+", lon="+lon1.toFixed(3);

        // Define JSON payload and send:
        var payload_inputs_json = JSON.stringify({"inputs":{"lon":lon1, "lat":lat1}})
        _ogcRequest(clickMarker, payload_inputs_json, paramstring) ;
    }

    // Define making request to OGC service (function):
    var _ogcRequest = function(clickMarker, payload_inputs_json, paramstring)  {
        console.log('Preparing to make HTTP POST request...')
        document.getElementById("displayGeoJSON").innerHTML = "waiting..."

        // Which process?
        var dropdown = document.getElementById("processes");
        var processId = dropdown.value;
        var processDesc = dropdown.options[dropdown.selectedIndex].text;

        // Construct HTTP request to OGC service:
        let xhrPygeo = new XMLHttpRequest();
        var url = "https://aqua.igb-berlin.de/pygeoapi/processes/"+processId+"/execution";
        xhrPygeo.open('POST', url, true)
        xhrPygeo.setRequestHeader('Content-Type', 'application/json');
        xhrPygeo.responseType = 'json';

        // Define behaviour for HTTP request:
        // First, error message (e.g. on HTTP 405 / CORS error):
        xhrPygeo.onerror = function() {
          console.error("Request failed.");
          if (xhrPygeo.status === 405) {
            console.error("Method Not Allowed (405) - likely OPTIONS request failed");
            clickMarker.bindPopup("HTTP request to service failed (HTTP "+xhrPygeo.status+"). Sorry for that.");
          } else if (xhrPygeo.status === 0) {
            console.error("We got status 0: Request failed or blocked (likely preflight failure)");
            clickMarker.bindPopup("HTTP request to service failed or blocked, probably a network problem or CORS error. Sorry for that.");
          }
          document.getElementById("displayGeoJSON").innerHTML = "nothing to display"
        };

        xhrPygeo.onreadystatechange = function () {
          if (xhrPygeo.readyState === XMLHttpRequest.DONE) {
            console.log("Request done with status:", xhrPygeo.status);
          }
        };
        xhrPygeo.onload = function() {
          console.log("Returning from OGC process: "+processId+"...");
          
          if (xhrPygeo.status == 200) {
            console.log("OGC server returned HTTP 200");
            clickMarker.bindPopup("Waiting for "+processDesc+" for "+paramstring+"...").openPopup();
          } else if (xhrPygeo.status == 400) {
            console.log("Oh no: Internal server error (HTTP 400)");
            var errmsg = xhrPygeo.response["description"];
            clickMarker.bindPopup(errmsg);
            document.getElementById("displayGeoJSON").innerHTML = errmsg
            return
          } else {
            console.log("Oh no: OGC server returned bad HTTP status: "+xhrPygeo.status);
            clickMarker.bindPopup("Failed for unspecified reason (possibly timeout), try another one!!");
            document.getElementById("displayGeoJSON").innerHTML = "nothing to display"
            return
          }

          // If there is no response, it might be a headwater!
          // Stream segments CAN be shown if it is a headwater! Then they would be returned!
          if (xhrPygeo.response == null){
            clickMarker.bindPopup("No "+lookingfor+", is this a headwater?").openPopup();
            // TODO Headwater, how to handle? Has not happened for a while, I think we now include the local
            // one itself to the upstream, so the response will not be null anywhere. Except for ocean I guess.
          } else {
            console.log('DEBUG: SERVER RESPONSE: '+xhrPygeo.response.type);
            console.log('DEBUG: SERVER RESPONSE AS JSON: '+JSON.stringify(xhrPygeo.response));
          }

          // Make layer(s) from GeoJSON that the server returned:
          var pygeoResponseGeoJSONLayer = L.geoJSON(xhrPygeo.response);

          // Style features depending on their properties:
          if (document.getElementById("stylingStrahlerToggle").checked){
            pygeoResponseGeoJSONLayer.eachLayer(styleLayerStrahler);
          } else {
            pygeoResponseGeoJSONLayer.eachLayer(styleLayerUni);
          }

          // Add styled layers to map:
          pygeoResponseGeoJSONLayer.addTo(map);
          allMyLayers.push(pygeoResponseGeoJSONLayer);
          console.log('Added layer to map...');
          map.fitBounds(pygeoResponseGeoJSONLayer.getBounds());
          console.log('Zoomed to layer...');
          clickMarker.closePopup();

          // Move web page to map!
          document.getElementById("scrollToTop").scrollIntoView();

          // Write GeoJSON into field so that user can copy-paste it:
          var prettyResponse = JSON.stringify(xhrPygeo.response, null, 2); // spacing level = 2
          document.getElementById("displayGeoJSON").innerHTML = prettyResponse;
        };

        // Send HTTP request:
        console.log('Sending HTTP POST request...')
        xhrPygeo.send(payload_inputs_json);
    }

    ////////////////////////////////////
    ////// Define button behaviour /////
    ////////////////////////////////////

    // Define behaviour for custom lonlat button (function):
    // Button clicked by user after entering their own coordinates (one or two pairs)
    var customButtonClickBehaviour = function() {
      console.log("User requested to use their own values...")

      // Get first (and only?) pair of coordinates:
      var lon1 = document.getElementById("customLon1").value;
      var lat1 = document.getElementById("customLat1").value;

      // Should we use subc_id instead of coordinates?
      var subcid1 = document.getElementById("customSubc1").value;
      var use_subcid1 = false;
      if (subcid1 === "") {
        console.log("Found no subcid1: "+ subcid1);
      } else {
        console.log("Found a subcid1: "+subcid1);
        use_subcid1 = true;
        subcid1 = parseInt(subcid1);
      }

      // Which process? Does it need one or two input coordinate pairs?
      var dropdown = document.getElementById("processes");
      let pairs = dropdown.options[dropdown.selectedIndex].dataset.pairs;
      if (pairs == "one") {

        if (!use_subcid1) {
          console.log("Clicked button for one coordinate pair: "+lon1+", "+lat1+" (lon, lat, WGS84)");
          clickMarker = putIconToClickLocation(lon1, lat1, map, "clicked on button", false);
          document.getElementById("scrollToTop").scrollIntoView();
          // Construct and send HTTP request to OGC service:
          ogcRequestOneCoordinatePair(clickMarker, lon1, lat1);

        } else {
          console.log("Clicked button for one subcid "+subcid1+".");
          // We have no click location... Putting it to a corner of the map, but it will stay at that map location...
          // TODO: Can we later move the clickmarker somewhere?
          //let northEast = map.getBounds().getNorthEast();
          //console.log("map getBounds: "+map.getBounds());
          //let lat = northEast.lat;
          //let lon = northEast.lng;
          //console.log('Map Northeast: '+lon+', '+lat);
          //clickMarker = putIconToClickLocation(lon, lat, map, "entered a subc_id (location unknown)", false);
          clickMarker = putIconToClickLocation(null, null, map, "entered a subc_id (location unknown)", false);
          // Reset result field:
          document.getElementById("responseField").innerHTML = "Response returned by server for subc_id <span class=\"code\">"+subcid1+"</span>...";
          document.getElementById("displayGeoJSON").innerHTML = "waiting..."
          // Construct and send HTTP request to OGC service:
          // Param string for logging
          var logstring = "subcid="+subcid1;
          // Define JSON payload and send:
          var payload_inputs_json = JSON.stringify({"inputs":{"subc_id":subcid1}})
          _ogcRequest(clickMarker, payload_inputs_json, logstring) ;
        }

      } else if (pairs == "two") {

        // Get second pair of coordinates:
        var lon2 = document.getElementById("customLon2").value;
        var lat2 = document.getElementById("customLat2").value;

        // Should we use subc_id instead of coordinates?
        var subcid2 = document.getElementById("customSubc2").value;
        var use_subcid2 = false;
        if (subcid2 === "") {
          console.log("Found no subcid2: "+ subcid2);
        } else {
          console.log("Found a subcid2: "+subcid2);
          use_subcid2 = true;
          subcid2 = parseInt(subcid2);
        }

        // Two coordinates:
        if (!use_subcid1 && !use_subcid2) {
          //buttonClickBehaviourTwoPairs(lon1, lat1, lon2, lat2); WIPPP
          console.log("Clicked button for two coordinate pairs: "+lon1+", "+lat1+" and "+lon2+", "+lat2+" (lon, lat, WGS84)");
          // Add icon and popup to click location:
          clickMarker = putIconToClickLocation(lon1, lat1, map, "clicked on button (part 1)", false);
          clickMarker = putIconToClickLocation(lon2, lat2, map, "clicked on button (part 2)", false);
          document.getElementById("scrollToTop").scrollIntoView();
          // Construct and send HTTP request to OGC service:
          ogcRequestTwoCoordinatePairs(clickMarker, lon1, lat1, lon2, lat2);

        // Two subcids:
        } else if (use_subcid1 && use_subcid2) {
          console.log("Clicked button for two subcids: "+subcid1+", "+subcid2+".");
          // We have no click location... Putting it to a corner of the map, but it will stay at that map location...
          // TODO: Can we later move the clickmarker somewhere?
          let northEast = map.getBounds().getNorthEast();
          let lat = northEast.lat;
          let lon = northEast.lng;
          console.log('Map Northeast: '+lon+', '+lat)
          clickMarker = putIconToClickLocation(lon, lat, map, "entered two subc_ids (location unknown)", false);
          // Reset result field:
          document.getElementById("responseField").innerHTML = "Response returned by server for subc_id <span class=\"code\">"+subcid1+"</span> to <span class=\"code\">"+subcid2+"...";
          document.getElementById("displayGeoJSON").innerHTML = "waiting..."
          // Construct and send HTTP request to OGC service:
          // Param string for logging
          var logstring = "subcid1="+subcid1+",subcid2="+subcid2;
          // Define JSON payload and send:
          var payload_inputs_json = JSON.stringify({"inputs":{"subc_id_start":subcid1, "subc_id_end": subcid2}})
          _ogcRequest(clickMarker, payload_inputs_json, logstring);

        // Mixed 1
        } else if (use_subcid1 && !use_subcid2) { WIP
          // Param string for logging
          var logstring = "subcid1="+subcid1+",lon2="+lon2+",lat2="+lat2;
          console.log("Clicked button for mixed: "+logstring+".");

          // We have no click location... Putting it to a corner of the map, but it will stay at that map location...
          // TODO: Can we later move the clickmarker somewhere?
          // WE NEED TWO CLICKMARKERS??? WIP
          //let northEast = map.getBounds().getNorthEast();
          //let lat = northEast.lat;
          //let lon = northEast.lng;
          //console.log('Map Northeast: '+lon+', '+lat)

          // Use known location for click marker (TODO IMPROVE)
          clickMarker = putIconToClickLocation(lon2, lat2, map, "entered two subc_ids (location unknown)", false);

          // Reset result field:
          document.getElementById("responseField").innerHTML = "Response returned by server for subc_id <span class=\"code\">"+subcid1+"</span> to <span class=\"code\">"+lon2+", "+lat2+"</span> (lon, lat, WGS84)...";
          document.getElementById("displayGeoJSON").innerHTML = "waiting..."

          // Construct and send HTTP request to OGC service:
          // Define JSON payload and send:
          var payload_inputs_json = JSON.stringify({"inputs":{"subc_id_start":subcid1, "lon_end": lon2, "lat_end": lat2}})
          _ogcRequest(clickMarker, payload_inputs_json, logstring);

        // Mixed 2:
        } else if (!use_subcid1 && use_subcid2) {
          var logstring = "lon1="+lon1+",lat1="+lat1+",subcid2="+subcid2;
          console.log("Clicked button for mixed: "+logstring+".");

          // We have no click location... Putting it to a corner of the map, but it will stay at that map location...
          // TODO: Can we later move the clickmarker somewhere?
          // WE NEED TWO CLICKMARKERS??? WIP
          //let northEast = map.getBounds().getNorthEast();
          //let lat = northEast.lat;
          //let lon = northEast.lng;
          //console.log('Map Northeast: '+lon+', '+lat)
          // Param string for logging

          // Use known location for click marker (TODO IMPROVE)
          clickMarker = putIconToClickLocation(lon1, lat1, map, "entered mixed "+logstring, false);

          // Reset result field:
          document.getElementById("responseField").innerHTML = "Response returned by server for <span class=\"code\">"+lon1+", "+lat1+"</span> (lon, lat, WGS84) to subc_id <span class=\"code\">"+subcid2+"</span>...";
          document.getElementById("displayGeoJSON").innerHTML = "waiting..."

          // Construct and send HTTP request to OGC service:
          // Define JSON payload and send:
          var payload_inputs_json = JSON.stringify({"inputs":{"lon_start": lon1, "lat_start": lat1, "subc_id_end":subcid2}})
          _ogcRequest(clickMarker, payload_inputs_json, logstring);
        }
      }
    }

    /////////////////////////////////////////////////////////////////
    //// Event Listeners for connecting the lon, lat input boxes ////
    /////////////////////////////////////////////////////////////////

    // If lonlat is changed by user, also change lon and lat:
    var eventLonLat1Changed = function(evt) {
      var temp = this.value.split(",");
      var newlon = parseFloat(temp[0]);
      var newlat = parseFloat(temp[1]);
      document.getElementById("customLon1").value = newlon;
      document.getElementById("customLat1").value = newlat;
      document.getElementById("customSubc1").value = "";
    };

    // If lon is changed by the user, also change lonlat
    var eventLon1Changed = function(evt) {
      var newlon = parseFloat(this.value);
      var oldlonlat = document.getElementById("customLonLat1").value;
      if (oldlonlat === "") { oldlonlat = "undefined,undefined" };
      var oldlat = oldlonlat.split(",")[1]
      var newlonlat = newlon+', '+oldlat;
      // This adds more and more spaces, so we remove double whitespace:
      newlonlat = newlonlat.replace("  ", " ");
      document.getElementById("customLonLat1").value = newlonlat;
      document.getElementById("customSubc1").value = "";
    };

    // If lat is changed by the user, also change lonlat
    var eventLatChanged = function(evt) {
      var newlat = parseFloat(this.value);
      var oldlonlat = document.getElementById("customLonLat1").value;
      if (oldlonlat === "") { oldlonlat = "undefined,undefined" };
      var oldlon = oldlonlat.split(",")[0]
      var newlonlat = oldlon+', '+newlat;
      document.getElementById("customLonLat1").value = newlonlat;
      document.getElementById("customSubc1").value = "";
    };

    // If the user adds a subc_id, remove all lon/lat coords:
    var eventSubcid1Changed = function(evt) {
      if (this.value == "") {
        console.log("FIRED: eventSubcid1Changed, with no value.");
      } else {
        console.log("FIRED: eventSubcid1Changed, with value "+this.value+" (now parsing to int).");
        var newsubcid = parseInt(this.value);
        document.getElementById("customSubc1").value = newsubcid;
        // No more coordinates:
        document.getElementById("customLon1").value = "";
        document.getElementById("customLat1").value = "";
        document.getElementById("customLonLat1").value = "";
      }
    };

    // When a user focuses on a coordinate field, empty the subcatchment field!
    var eventCoord1Focus = function(evt) {
      document.getElementById("customSubc1").value = "";
    };
    var eventCoord2Focus = function(evt) {
      document.getElementById("customSubc2").value = "";
    };

    // Same for the second set, which is usually invisible, unless
    // when a process is selected that needs two locations (routing)
    var eventLonLat2Changed = function(evt) {
      var temp = this.value.split(",");
      var newlon = parseFloat(temp[0]);
      var newlat = parseFloat(temp[1]);
      document.getElementById("customLon2").value = newlon;
      document.getElementById("customLat2").value = newlat;
      document.getElementById("customSubc2").value = "";
    };

    var eventLon2Changed = function(evt) {
      var newlon = parseFloat(this.value);
      var oldlonlat = document.getElementById("customLonLat2").value;
      if (oldlonlat === "") { oldlonlat = "undefined,undefined" };
      var newlonlat = newlon+', '+oldlonlat.split(",")[1];
      document.getElementById("customLonLat2").value = newlonlat;
      document.getElementById("customSubc2").value = "";
    };

    // Define event listeners for custom lon and lat
    var eventLat2Changed = function(evt) {
      var newlat = parseFloat(this.value);
      var oldlonlat = document.getElementById("customLonLat2").value;
      if (oldlonlat === "") { oldlonlat = "undefined,undefined" };
      var newlonlat = oldlonlat.split(",")[0]+', '+newlat;
      document.getElementById("customLonLat2").value = newlonlat;
      document.getElementById("customSubc2").value = "";
    };

    var eventSubcid2Changed = function(evt) {
      if (this.value == "") {
        console.log("FIRED: eventSubcid2Changed, with no value.");
      } else {
        console.log("FIRED: eventSubcid2Changed, with value "+this.value+" (now parsing to int).");
        var newsubcid = parseInt(this.value);
        document.getElementById("customSubc2").value = newsubcid;
        // No more coordinates:
        document.getElementById("customLon2").value = "";
        document.getElementById("customLat2").value = "";
        document.getElementById("customLonLat2").value = "";
      }
    };


    ///////////////////////////////
    //// Other Event Listeners ////
    ///////////////////////////////

    // Define event listener for adding custom GeoJSON
    // First, define a container for GeoJSON layer
    var geoJsonLayer;
    // Now, define the behaviour:
    var eventCustomGeojsonDisplay = function(evt) {
      try {
        let input = document.getElementById('customGeoJsonArea').value;
        let geojson = JSON.parse(input);

        // Remove existing layer if present
        if (geoJsonLayer) {
          map.removeLayer(geoJsonLayer);
        }

        // Add new GeoJSON layer, zoom to bounds
        geoJsonLayer = L.geoJSON(geojson).addTo(map);

        // Zoom to bounds of new layer, scroll up to map:
        map.fitBounds(geoJsonLayer.getBounds());
        //document.getElementById("map").scrollIntoView();
        document.getElementById("scrollToTop").scrollIntoView();
        // TODO: Can we add up, instead of removing previous? Then, add a delete button?

      } catch (err) {
        alert("Invalid GeoJSON:\n" + err.message);
      }
    };

    // Define event listener for change of process id, so I can switch off/ switch on
    // the buttons for examples (which only work for one-click examples)!
    var eventProcessChanged = function(evt){
      console.log("Process changed to: "+this.value);

      // Is this a process that needs one or two coordinate pairs?
      let pairs = evt.target.options[evt.target.selectedIndex].dataset.pairs;
      console.log("Process needs "+pairs+" coordinate pairs.");
      if (pairs == 'two') {
        defineTwoClickExampleButtons();
        var divsToHide = document.getElementsByClassName("fortwo");
        for(var i = 0; i < divsToHide.length; i++){
          divsToHide[i].classList.remove('invisible');
        }
      } else {
        defineOneClickExampleButtons();
        var divsToHide = document.getElementsByClassName("fortwo");
        for(var i = 0; i < divsToHide.length; i++){
          divsToHide[i].classList.add('invisible');
        }
      }

      // Previously, we had to disable the example buttons once a two-pair process
      // was selected, as we had no two-pair examples - now we do.
      //
      // But in case we include processes where we need to disable again:
      //if (pairs == 'n') {
      //  // now, n clicks are needed and our examples don't work anymore:
      //  let exampleButtons = document.getElementsByClassName("oneclickexample");
      //  for (let i = 0; i < exampleButtons.length; i++) {
      //    exampleButtons[i].disabled = true;
      //  }
      //} else {
      // now, 1-2 clicks are needed and our examples will work:
      //  let exampleButtons = document.getElementsByClassName("oneclickexample");
      //  for (let i = 0; i < exampleButtons.length; i++) {
      //    exampleButtons[i].disabled = false;
      //  }
      //}
    }

    ////////////////////////////////////
    //// Example Buttons: Behaviour ////
    ////////////////////////////////////

    // Define behaviour for example button (function):
    var exampleButtonClickBehaviourOnePair = function() {
      console.log("User requested to use example values...")
      var caller = event.target;
      console.log("Caller: "+caller)
      console.log("Button who called this: "+caller.id)
      var lon1 = caller.getAttribute("thislon");
      var lat1 = caller.getAttribute("thislat");
      console.log("Example coordinate pair: "+lon1+", "+lat1+" (lon, lat, WGS84)")
      //buttonClickBehaviourOnePair(lon1, lat1);
      console.log("Clicked button for one coordinate pair: "+lon1+", "+lat1+" (lon, lat, WGS84)");
      // Add icon and popup to click location:
      clickMarker = putIconToClickLocation(lon1, lat1, map, "clicked on button", false);
      document.getElementById("scrollToTop").scrollIntoView();
      // Construct and send HTTP request to OGC service:
      ogcRequestOneCoordinatePair(clickMarker, lon1, lat1);
    }

    // Define behaviour for example button (function):
    var exampleButtonClickBehaviourTwoPairs = function() {
      console.log("User requested to use example values...")
      var caller = event.target;
      console.log("Caller: "+caller)
      console.log("Button who called this: "+caller.id)
      var lon1 = caller.getAttribute("thislon");
      var lat1 = caller.getAttribute("thislat");
      var lon2 = caller.getAttribute("thislon2");
      var lat2 = caller.getAttribute("thislat2");
      console.log("Example coordinate pairs: "+lon1+", "+lat1+" and "+lon2+", "+lat2+" (lon, lat, WGS84)")
      //buttonClickBehaviourTwoPairs(lon1, lat1, lon2, lat2);
      console.log("Clicked button for two coordinate pairs: "+lon1+", "+lat1+" and "+lon2+", "+lat2+" (lon, lat, WGS84)");
      // Add icon and popup to click location:
      clickMarker = putIconToClickLocation(lon1, lat1, map, "clicked on button (part 1)", false);
      clickMarker = putIconToClickLocation(lon2, lat2, map, "clicked on button (part 2)", false);
      document.getElementById("scrollToTop").scrollIntoView();
      // Construct and send HTTP request to OGC service:
      ogcRequestTwoCoordinatePairs(clickMarker, lon1, lat1, lon2, lat2)
    }

    // Define programatically content/text of buttons:
    var defineTwoClickExampleButtons = function() {
      var examples = {
        ex1: {lon: 9.001922607421877,  lat: 52.91177308077004, lon2: 9.055137634277346,  lat2: 52.90224825087554,  text: "Near Schwarme", desc: "few segments"},
        ex2: {lon: 12.577028274536135, lat: 51.38613070285945, lon2: 12.564454078674318, lat2: 51.36524123530659,  text: "Wachtelteich", desc: "few segments"},
        ex3: {lon: 13.542366027832033, lat: 52.44028788912483, lon2: 13.283157348632814, lat2: 52.454516998017894, text: "Adlershof to Dahlem", desc: "not many segments ...via Krumme Lanke, Wannsee, Havel, Spree, Teltowkanal"},
        ex4: {lon: 12.115173339843752, lat: 53.44051847367499, lon2: 12.113800048828127, lat2: 53.149131411867074, text: "Pritzwalk to Plau via Elbe", desc: "many segments"},
        ex5: {lon: 13.051757812500002, lat: 50.85959488957681, lon2: 14.414062500000002, lat2: 51.08098143406474,  text: "Chemnitz to Wilthen via Elbe, Havel, Spree", desc: "very many segments"},
      };
      _defineExampleButtons(examples, true)
    }

    //////////////////////////////////
    //// Generate Example Buttons ////
    //////////////////////////////////

    // Define programatically content/text of buttons:
    var defineOneClickExampleButtons = function() {
      var examples = {
        ex1: {lon: 10.055837,         lat: 53.483139,         text: "Östlich von Hamburg", desc: "11 subcatchments"},
        ex2: {lon: 9.109039306640627, lat: 52.7810591224723,  text: "Bei Hoya", desc: "403 subcatchments"},
        ex3: {lon: 9.973955154418947, lat: 53.54193634826804, text: "Elbe in Hamburg", desc: "8071 subcatchments"},
        ex4: {lon: 9.17770385,        lat: 52.957628575,      text: "Weser bei Verden (Aller)", desc: "208433 subcatchments - only bbox works"},
        ex5: {lon: 9.921666666666667, lat: 54.69166666666666, text: "Nördlich von Kappeln (Schlei)", desc: "exactly on boundary"},
      };
      _defineExampleButtons(examples, false)
      // Finland, 47 subcatchments: 24.941250085830692, 60.385753944192324
    }

    // Define programatically content/text of buttons:
    var _defineExampleButtons = function(examples, twopairs) {

      // Define example values for buttons:
      // TODO: CODE STUPIDITY: Fill the button table and their attributes in a for loop...
      // TODO: EFFICIENCY: Have them all, just set display none if not needed!

      var buttonEx = document.getElementById("example1");
      var textEx = document.getElementById("example1desc");
      var example = examples.ex1
      buttonEx.innerHTML = example.text
      textEx.innerHTML = example.desc + " <span class=\"code\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      //textEx.innerHTML = example.desc + " <span class=\"lightsmall\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      buttonEx.setAttribute("thislon", example.lon)
      buttonEx.setAttribute("thislat", example.lat)
      if (twopairs) {
        buttonEx.setAttribute("thislon2", example.lon2)
        buttonEx.setAttribute("thislat2", example.lat2)
        buttonEx.onclick = exampleButtonClickBehaviourTwoPairs;
      } else {
        buttonEx.setAttribute("thislon2", null)
        buttonEx.setAttribute("thislat2", null)
        buttonEx.onclick = exampleButtonClickBehaviourOnePair;
      }

      var buttonEx = document.getElementById("example2");
      var textEx = document.getElementById("example2desc");
      var example = examples.ex2
      buttonEx.innerHTML = example.text
      textEx.innerHTML = example.desc + " <span class=\"code\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      //textEx.innerHTML = example.desc + " <span class=\"lightsmall\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      buttonEx.setAttribute("thislon", example.lon)
      buttonEx.setAttribute("thislat", example.lat)
      if (twopairs) {
        buttonEx.setAttribute("thislon2", example.lon2)
        buttonEx.setAttribute("thislat2", example.lat2)
        buttonEx.onclick = exampleButtonClickBehaviourTwoPairs;
      } else {
        buttonEx.setAttribute("thislon2", null)
        buttonEx.setAttribute("thislat2", null)
        buttonEx.onclick = exampleButtonClickBehaviourOnePair;
      }

      var buttonEx = document.getElementById("example3");
      var textEx = document.getElementById("example3desc");
      var example = examples.ex3
      buttonEx.innerHTML = example.text
      textEx.innerHTML = example.desc + " <span class=\"code\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      //textEx.innerHTML = example.desc + " <span class=\"lightsmall\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      buttonEx.setAttribute("thislon", example.lon)
      buttonEx.setAttribute("thislat", example.lat)
      if (twopairs) {
        buttonEx.setAttribute("thislon2", example.lon2)
        buttonEx.setAttribute("thislat2", example.lat2)
        buttonEx.onclick = exampleButtonClickBehaviourTwoPairs;
      } else {
        buttonEx.setAttribute("thislon2", null)
        buttonEx.setAttribute("thislat2", null)
        buttonEx.onclick = exampleButtonClickBehaviourOnePair;
      }

      var buttonEx = document.getElementById("example4");
      var textEx = document.getElementById("example4desc");
      var example = examples.ex4
      buttonEx.innerHTML = example.text
      textEx.innerHTML = example.desc + " <span class=\"code\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      //textEx.innerHTML = example.desc + " <span class=\"lightsmall\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      buttonEx.setAttribute("thislon", example.lon)
      buttonEx.setAttribute("thislat", example.lat)
      if (twopairs) {
        buttonEx.setAttribute("thislon2", example.lon2)
        buttonEx.setAttribute("thislat2", example.lat2)
        buttonEx.onclick = exampleButtonClickBehaviourTwoPairs;
      } else {
        buttonEx.setAttribute("thislon2", null)
        buttonEx.setAttribute("thislat2", null)
        buttonEx.onclick = exampleButtonClickBehaviourOnePair;
      }

      var buttonEx = document.getElementById("example5");
      var textEx = document.getElementById("example5desc");
      var example = examples.ex5
      buttonEx.innerHTML = example.text
      textEx.innerHTML = example.desc + " <span class=\"code\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      //textEx.innerHTML = example.desc + " <span class=\"lightsmall\">(lon = "+example.lon+", lat = "+example.lat+")</span>";
      buttonEx.setAttribute("thislon", example.lon)
      buttonEx.setAttribute("thislat", example.lat)
      if (twopairs) {
        buttonEx.setAttribute("thislon2", example.lon2)
        buttonEx.setAttribute("thislat2", example.lat2)
        buttonEx.onclick = exampleButtonClickBehaviourTwoPairs;
      } else {
        buttonEx.setAttribute("thislon2", null)
        buttonEx.setAttribute("thislat2", null)
        buttonEx.onclick = exampleButtonClickBehaviourOnePair;
      }
    }

    ///////////////////////////////
    //// Other functions ////
    ///////////////////////////////

    // Function to add a grey marker, and a pop-up, to a location on the map
    var putIconToClickLocation = function(lon1, lat1, map, actionDone, askToClickAgain) {
      console.log("User "+actionDone+" (coordinates: "+lon1+", "+lat1+" (lon, lat, WGS84)");
      var iconheight = 30;
      var iconwidth = 0.61*iconheight;

      if (lon1 === null) {
        var latlon = map.getCenter();
        var logstring = "no coord chosennn, using map centre..."+latlon;
        console.log("LOGGISRING "+logstring);
        var iconUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // 1x1 transparent gif
        var iconSize = [1, 1]; // minimal size
      } else {
        var lon1 = parseFloat(lon1);
        var lat1 = parseFloat(lat1);
        var latlon = [lat1, lon1];
        var logstring = lon1.toFixed(3)+", "+lat1.toFixed(3)+" (lon, lat)...";
        var iconSize = [iconwidth, iconheight];
        var iconUrl = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png';
      }

      // Icon for user-clicks
      var clickIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png',
        iconSize: iconSize,
        iconAnchor: [iconwidth*0.5, iconheight], // from top left corner: go half-width to right, full-height to bottom 
        popupAnchor: [0, -iconheight-5] // where iconAnchor is, go full-height to top plus 5 pixels
      });
      let clickMarker = L.marker(latlon, {icon: clickIcon}).addTo(map);
      allMyIcons.push(clickMarker);

      // Add Popup to user-click
      var dropdown = document.getElementById("processes");
      var lookingfor = dropdown.options[dropdown.selectedIndex].text
      if (askToClickAgain) {
        clickMarker.bindPopup("You selected "+lookingfor+", so please click another time!").openPopup();
      } else {
        clickMarker.bindPopup("Waiting for "+lookingfor+" for "+logstring).openPopup();
      }
      console.log("When clicked, this process was selected: "+dropdown.value+"...");
      return (clickMarker);
    }

    // Global variables needed for behaviour on map click:
    var thisIsSecondClick = false;
    var firstClickLon = null;
    var firstClickLat = null;

    // Define behaviour on map click (function)
    var mapClickBehaviour = function(evt) {

      // Get coordinates from click location:
      clicklon = evt.latlng.lng;
      clicklat = evt.latlng.lat;
      console.log('There was a click: '+clicklat+', '+clicklon+' (lon, lat, WGS84)');

      // Check if we need two points!
      var dropdown = document.getElementById("processes");
      let pairs = dropdown.options[dropdown.selectedIndex].dataset.pairs;
      if (pairs == "two") {
        console.log('Any function requiring two pairs of coordinates...');

        if (thisIsSecondClick) {
          // Second click of two!
          // Make sure the next click is counted the first:
          thisIsSecondClick = false;

          // Add icon and popup to click location:
          clickMarker = putIconToClickLocation(clicklon, clicklat, map, "clicked on map", false);

          // Construct and send HTTP request to OGC service:
          ogcRequestTwoCoordinatePairs(clickMarker, firstClickLon, firstClickLat, clicklon, clicklat);

        } else {
          // First click of two!
          // Make sure the next click is counted the second:
          thisIsSecondClick = true;

          // Add icon and popup to click location, telling user to click again
          clickMarker = putIconToClickLocation(clicklon, clicklat, map, "clicked on map", true);

          // Remember the coordinates of this first click, for the second:
          firstClickLat = clicklat;
          firstClickLon = clicklon;
        }

      // Normal process that works with one click!
      } else {
        console.log('Any function requiring just one pair of coordinates...');

        // Add icon and popup to click location:
        clickMarker = putIconToClickLocation(clicklon, clicklat, map, "clicked on map", false);

        // Construct and send HTTP request to OGC service:
        ogcRequestOneCoordinatePair(clickMarker, clicklon, clicklat);
      }
    };

    // Define clearing the map
    var clearMap = function() {
      for (var i = 0; i < allMyLayers.length; i++) {
        map.removeLayer(allMyLayers[i]);
      };
      for (var i = 0; i < allMyIcons.length; i++) {
        map.removeLayer(allMyIcons[i]);
      };
      document.getElementById("displayGeoJSON").innerHTML = "";
    }


    //////////////////////////////////////////
    //// Define buttons and add behaviour ////
    //////////////////////////////////////////

    // Run the button content/text definition:
    defineOneClickExampleButtons();

    // Bind custom-button behaviour to the custom-button click event:
    document.getElementById("clearMapButton").onclick = clearMap;

    // Bind custom-button behaviour to the custom-button click event:
    document.getElementById("customLonlatButton").onclick = customButtonClickBehaviour;

    // Bind one-click or two-click to the event of process change:
    document.getElementById("processes").addEventListener('input', eventProcessChanged);

    // When a user modifies text fields "lon", "lat" or "lon,lat", modify the others accordinly:
    document.getElementById("customLonLat1").addEventListener('input', eventLonLat1Changed);
    document.getElementById("customLon1").addEventListener('input', eventLon1Changed);
    document.getElementById("customLat1").addEventListener('input', eventLatChanged);
    document.getElementById("customLonLat2").addEventListener('input', eventLonLat2Changed);
    document.getElementById("customLon2").addEventListener('input', eventLon2Changed);
    document.getElementById("customLat2").addEventListener('input', eventLat2Changed);
    // When a user modifies/focuses the subcatchment id field, remove the coordinates:
    document.getElementById("customSubc1").addEventListener('input', eventSubcid1Changed);
    document.getElementById("customSubc1").addEventListener('focus', eventSubcid1Changed);
    document.getElementById("customSubc2").addEventListener('input', eventSubcid2Changed);
    document.getElementById("customSubc2").addEventListener('focus', eventSubcid2Changed);
    // When a user focuses back on coordinates, remove the subcatchment fields:
    document.getElementById("customLonLat1").addEventListener('focus', eventCoord1Focus);
    document.getElementById("customLon1").addEventListener('focus', eventCoord1Focus);
    document.getElementById("customLat1").addEventListener('focus', eventCoord1Focus);
    document.getElementById("customLonLat2").addEventListener('focus', eventCoord2Focus);
    document.getElementById("customLon2").addEventListener('focus', eventCoord2Focus);
    document.getElementById("customLat2").addEventListener('focus', eventCoord2Focus);

    // When a user clicks the button to display custom GeoJSON
    document.getElementById('customGeoJsonButton').addEventListener('click', eventCustomGeojsonDisplay);

    // Bind map click behaviour to the map click event:
    console.log('Waiting for user to click to get a coordinate...');
    map.on('click', mapClickBehaviour);


  </script>
</body>

</html>

