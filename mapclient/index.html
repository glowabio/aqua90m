<!--#https://www.geeksforgeeks.org/using-leaflet-js-to-show-maps-in-a-webpage/-->

<!DOCTYPE html>
<html>

<head>
  <title>Hydrography90m</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Get the leaflet CSS file -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
integrity=
"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
    crossorigin="" />
  <link rel="stylesheet" href="mystyle.css"/ >
</head>

<body>
  <h1>On the fly upstream catchments</h1>
  <!--h1>TEMPORARILY OFFLINE: On the fly upstream catchments</h1-->


  <!-- Selection -->
  <p><span>Click on the map to display:</span></p>
  <select id="processes">
    <option value="get-upstream-bbox">Upstream bounding box</option>
    <option value="get-upstream-dissolved-cont">Upstream catchment (one large polygon)</option>
    <option value="get-upstream-subcatchments">Upstream catchment (individual polygons)</option>
    <option value="get-upstream-streamsegments">Upstream stream segments</option>
    <option value="get-local-streamsegments">Local stream segment</option>
    <option value="get-local-streamsegments-subcatchments">Local stream segment and local subcatchment</option>
    <option value="get-snapped-points">Snapped point</option>
    <option value="get-snapped-point-plus">Snapped point, local stream segment and local subcatchment</option>
    <option value="get-shortest-path-to-outlet">Shortest path from point to sea</option>
    <option value="get-shortest-path-two-points">Shortest path from point to point (NOT YET)</option>
  </select>
  <p>
  <span>(please choose!)...</span>
  <br />
  <br />
  <span class="greynote">Note: Computing may take some time, depending on catchment size!</span>
  <br />
  <span class="greynote">Note: In case you click to a headwater, no upstream catchment is provided, as no upstream exists...</span>
  </p>


  <!-- Map -->
  <div id="map" style="width: 960px; height: 500px"></div>


  <!-- Custom lonlat button -->
  <h3>Input your own coordinates...</h3>
  <table>
    <tr>
    <!-- If you want the grey examples to disappear on focus, set onfocus to this:   onfocus="if(this.value=='9.17'){ this.value='NIX'; this.style.color='#000';}"   -->
      <td>Longitude:</td>
      <td>
        <input type="text" id="custom_lon" value="9.17"
          onblur="if(this.value==''){ this.value='9.17'; this.style.color='#BBB';}"
          onfocus="if(this.value=='9.17'){ this.value='9.17'; this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. 9.17</td>
    </tr>
    <tr>
      <td>Latitude:</td>
      <td>
        <input type="text" id="custom_lat" value="52.95"
          onblur="if(this.value==''){ this.value='52.95'; this.style.color='#BBB';}"
          onfocus="if(this.value=='9.17'){ this.value='52.95'; this.style.color='#000';}"
          style="color:#BBB;" />
      </td>
      <td>e.g. 52.95</td>
    </tr>
  </table>
  <!-- Behaviour is defined programmatically further below -->
  <button id="customLonlatButton">Use these values!</button>


  <!-- Example buttons -->
  <h3>...or use these examples:</h3>
  <table>
    <tr>
      <td><button id="example2" onclick="return buttonClickBehaviour('9.17770385', '52.957628575')">lon=9.17770385, lat=52.957628575</button></td>
      <td>(208433 subcatchments - only bbox works)</td>
    </tr>
    <tr>
      <td><button id="example3" onclick="return buttonClickBehaviour('9.109039306640627', '52.7810591224723')">lon=9.1090393, lat=52.781059</button></td>
      <td>(403 subcatchments</td>
    </tr>
    <tr>
      <td><button id="example4" onclick="return buttonClickBehaviour('10.055837', '53.483139')">lon=10.055837, lat=53.483139</button></td>
      <td>(11 subcatchments)</td>
    </tr>
    <tr>
      <td><button id="example5" onclick="return buttonClickBehaviour('9.973955154418947', '53.54193634826804')">lon=9.973955, lat=53.541936</button></td>
      <td>(8071 subcatchments)</td>
    </tr>
    <tr>
      <td><button id="example6" onclick="return buttonClickBehaviour('9.921666666666667', '54.69166666666666')">lon=9.921666666666667, lat=54.69166666666666</button></td>
      <td>(exactly on boundary)</td>
    </tr>
  </table>



  <!-- Text field -->
  <p id="responseField">Response returned by server:</p>
  <textarea id="display_geojson" rows="20", cols="120">(Result GeoJSON will be displayed here)</textarea>


  <!-- Get the leaflet JavaScript file -->
  <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet.js"
    integrity=
"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew=="
    crossorigin=""></script>
  <script>

    // Initialize the map
    const map = L.map('map')

    // Get the tile layer from OpenStreetMaps
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {

    // Specify the maximum zoom of the map
    maxZoom: 19,

    // Set the attribution for OpenStreetMaps
    attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Set the view of the map
    // with the latitude, longitude and the zoom value
    // map.setView([60.19123, 24.94612], 10); // Helsinki
    map.setView([53.014, 12.008], 7); // Northern Germany

    // Show a marker at the position of Helsinki
    //let eiffelMarker = L.marker([60.19123, 24.94612]).addTo(map);
    // Bind popup to the marker with a popup
    //eiffelMarker.bindPopup("Helsinki").openPopup();

    // Other way. WORKS!
    //L.geoJSON(data, {
    //    style: function(feature) {
    //        switch (feature.properties.UnitID) {
    //            case 1: return {color: "#ff0000"};
    //            case 2: return {color: "#0000ff"};
    //      default: return {color: "#ff8c00"};
    //        }
    //    }
    //}).addTo(map);


    // DISPLAY DATA FROM WPS CALL ON MAP, STATIC:
    // https://gis.stackexchange.com/questions/68489/loading-external-geojson-file-into-leaflet-map
    //let xhrWps = new XMLHttpRequest();
    //var urlWps = "https://aqua.igb-berlin.de/pygeoapi/processes/get-upstream-dissolved/execution";
    //xhrWps.open('POST', urlWps, true)
    //var inputsWpsCall = JSON.stringify({"inputs":{"lon":9.931555, "lat":54.695070}})
    //xhrWps.setRequestHeader('Content-Type', 'application/json');
    //xhrWps.responseType = 'json';
    //xhrWps.onload = function() {
    //    if (xhrWps.status !== 200) return
    //    L.geoJSON(xhrWps.response).addTo(map);
    //};
    //xhrWps.send(inputsWpsCall);


    var ogcRequest = function(dropdown, paramlon, paramlat, clickMarker) {
        console.log('Preparing to make HTTP POST request triggered by button-click')
        document.getElementById("responseField").innerHTML = "Reesponse returned by server for lon "+paramlon+", lat = "+paramlat+"...";

        // Parse coordinates to Float
        var lat = parseFloat(paramlat);
        var lon = parseFloat(paramlon);

        // Which process?
        var processId = dropdown.value;
        var processDesc = dropdown.options[dropdown.selectedIndex].text;

        // Construct HTTP request to OGC service:
        var payload_inputs_json = JSON.stringify({"inputs":{"lon":lon, "lat":lat}})
        let xhrPygeo = new XMLHttpRequest();
        var url = "https://aqua.igb-berlin.de/pygeoapi/processes/"+processId+"/execution";
        xhrPygeo.open('POST', url, true)

        xhrPygeo.setRequestHeader('Content-Type', 'application/json');
        xhrPygeo.responseType = 'json';

        // Define behaviour for HTTP request:
        xhrPygeo.onload = function() {
          console.log("Returning from OGC process: "+processId+"...");
          
          if (xhrPygeo.status == 200) {
            console.log("OGC server returned HTTP 200");
            clickMarker.bindPopup("Waiting for "+processDesc+" for lat="+lat.toFixed(3)+", lon="+lon.toFixed(3)+"...").openPopup();
          } else if (xhrPygeo.status == 400) {
            console.log("Oh no: Internal server error (HTTP 400)");
            var errmsg = xhrPygeo.response["description"];
            clickMarker.bindPopup(errmsg);
            return
          } else {
            console.log("Oh no: OGC server returned bad HTTP status: "+xhrPygeo.status);
            clickMarker.bindPopup("Failed for unspecified reason (possibly timeout), try another one!!");
            return
          }

          // If there is no response, it might be a headwater!
          // Stream segments CAN be shown if it is a headwater! Then they would be returned!
          if (xhrPygeo.response == null){
            clickMarker.bindPopup("No "+lookingfor+", is this a headwater?").openPopup();
            // TODO Stop here?
          } else {
            console.log('DEBUG: SERVER RESPONSE: '+xhrPygeo.response.type);
            console.log('DEBUG: SERVER RESPONSE AS JSON: '+JSON.stringify(xhrPygeo.response));
          }

          // Add to map the GeoJSON that the server returned
          //L.geoJSON(xhrPygeo.response).addTo(map);

          // Make layer(s) from GeoJSON that the server returned:
          var layer = L.geoJSON(xhrPygeo.response);

          // Style features depending on their properties:
          layer.eachLayer(function (layer) {
            if (layer.feature.properties.description == 'connecting line') {
              layer.setStyle({fillColor: 'red', color: 'red'});
              console.log('Found a connecting line and painted it red...');
            } else {
              console.log('Found any feature, no particular styling...');
            }
          });

          // Add styled layers to map:
          layer.addTo(map);
          console.log('Added layer to map...')
          clickMarker.closePopup();

          // Write GeoJSON into field so that user can copy-paste it:
          var prettyResponse = JSON.stringify(xhrPygeo.response, null, 2); // spacing level = 2
          document.getElementById("display_geojson").innerHTML = prettyResponse;
        };

        // Send HTTP request:
        console.log('Sending HTTP POST request triggered by button-click')
        xhrPygeo.send(payload_inputs_json);
    }

    // Define button behaviour (function):
    var buttonClickBehaviour = function(paramlon, paramlat){
      console.log("Clicked button for "+paramlon+", "+paramlat);

      // Add icon and popup to click location:
      clickMarker = putIconToClickLocation(paramlat, paramlon, map, "clicked on button");

      // Construct and send HTTP request to OGC service:
      var dropdown = document.getElementById("processes");
      ogcRequest(dropdown, paramlon, paramlat, clickMarker);
    };


    // Define behaviour for custom lonlat button (function):
    var customButtonClickBehaviour = function() {
      console.log("User requested to use their own values...")
      var paramlon = document.getElementById("custom_lon").value;
      var paramlat = document.getElementById("custom_lat").value;
      buttonClickBehaviour(paramlon, paramlat);
    }

    // Bind custom-button behaviour to the custom-button click event:
    document.getElementById("customLonlatButton").onclick = customButtonClickBehaviour;

    // This fires immediately on load!
    //button1.onclick = buttonClickBehaviour(clicklon, clicklat);


    // Function to add a grey marker, and a pop-up, to a location on the map
    var putIconToClickLocation = function(paramlat, paramlon, map, actionDone) {
      console.log("User "+actionDone+" (coordinates lon "+paramlon+", lat "+paramlat);
      var lat = parseFloat(paramlat);
      var lon = parseFloat(paramlon);

      // Icon for user-clicks
      var iconheight = 30;
      var iconwidth = 0.61*iconheight;
      var clickIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png',
        iconSize: [iconwidth, iconheight],
        iconAnchor: [iconwidth*0.5, iconheight], // from top left corner: go half-width to right, full-height to bottom 
        popupAnchor: [0, -iconheight-5] // where iconAnchor is, go full-height to top plus 5 pixels
      });
      let clickMarker = L.marker([lat, lon], {icon: clickIcon}).addTo(map);

      // Add Popup to user-click
      var dropdown = document.getElementById("processes");
      var lookingfor = dropdown.options[dropdown.selectedIndex].text
      clickMarker.bindPopup("Waiting for "+lookingfor+" for lat="+lat.toFixed(3)+", lon="+lon.toFixed(3)+"...").openPopup();
      console.log("When clicked, this process was selected: "+dropdown.value+"...");
      return (clickMarker);
    }

    var mapClickBehaviour = function(e) {
      // Get coordinates from click location:
      clicklat = e.latlng.lat;
      clicklon = e.latlng.lng;
      console.log('There was a click: lat '+clicklat+', lon '+clicklon);

      // Add icon and popup to click location:
      clickMarker = putIconToClickLocation(clicklat, clicklon, map, "clicked on map");

      // Construct and send HTTP request to OGC service:
      var dropdown = document.getElementById("processes");
      ogcRequest(dropdown, clicklon, clicklat, clickMarker);
    }


    // GET COORDINATES FROM MAP:
    console.log('Waiting for user to click to get a coordinate...');
    map.on('click', mapClickBehaviour);


  </script>
</body>

</html>

